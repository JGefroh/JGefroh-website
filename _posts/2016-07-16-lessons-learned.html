---
layout: post
title: Lessons Learned
blurb: A collection of lessons learned.
tags: [Leadership, Software Engineering]
---
<label class="header">Sometimes a simple bandaid is better than fixing the root problem</label>
<p>A project I was on had a feature that allowed users to generate a .pdf report that pulled from multiple legacy data sources. Users complained that this feature was "too slow" - they got bored watching the loading indicator spin while generating the report and requested that we make it faster.</p>

<p>The problem was that much of the slowdown came from the legacy systems. We measured and optimized what we could on our end, but we just couldn't make it noticeably faster than it already without a significant, costly, and risky redo.</p>

<p>Around this time I had been reading some books on UX design, and I remembered a story in one about people waiting for elevators. The elevators were taking too long to arrive and the people were impatient. Instead of replacing the entire elevator system with a faster model, the building managers simply installed mirrors in the hallway near the elevators. People stopped complaining about the slow elevators. Why? The speed of the elevators hadn't changed! However, the perception of time had changed because people were busy looking at themselves in the mirrors. The end result was the same - people no longer thought the elevators were too slow.</p>

<p>Following this train of thought, I tweaked the speed of the loading indicator to spin significantly faster than it had before. We ditched the low-impact optimizations we made (changing the code decreased clarity and introduced risk for little-to-no value) and deployed only the loading indicator change. Guess what? People stopped complaining about the reports being slow! Because the spinner spun faster, people perceived the report as loading faster and therefore were more satisfied with the speed of the system.</p>

<label class="header">Never use floats for monetary values.</label>
<p>A legacy project I worked on used floats to store monetary values. There was logic that required certain actions to be taken (such as closing an account or sending an invoice) when the value reached certain thresholds.</p>

<p>Unfortunately, the logic didn't work because sometimes the same value was stored as a float that was above the threshold or below the threshold (eg. `0.01` stored as `0.00999993` or `0.0100000004`).</p>

<p>Our work-around was to add a small fudge factor to reduce (but not eliminate) the number of errors. We were unable to change the data type due to many factors.</p>


<label class="header">It's easier to beg for forgiveness than to ask for permission, and there's no better way to prove your point than with overwhelming competency.</label>

<p>I've learned this plenty of times. One example is when I kept receiving a UI request from a senior project member that I knew would confuse people. I asked for permission to change it. I countered with usability principles and alternate suggestions but they refused to budge, citing usability as "subjective".</p>

<p>I did hallway usability tests on the UI and sure enough, people got very confused (even to the point where they were unable to continue their tasks).</p>

<p>I changed it to one of my alternate UI suggestions, conducted hallway usability tests again and nobody got stuck on it. From that point on, whenever I received a demand that was misinformed or a better alternative existed, I did what I thought was best without asking for permission. The project turned out better for it.</p>

<p>A lot of times, people don't listen to reason, or logic. They don't like to change or admit they are wrong. It's a natural feeling, but the enemy of improvement. Just do it, and do it well.</p>

<label class="header">As a team lead, you're responsible for every failure.</label>
<p>You can't pass the buck as a leader. When it comes down to it, if your team did something under your watch, you're 100% responsible. Whether you allowed it, or created an environment in which that failure could occur, it's your fault. Own up to it, learn from it, and move on.</p>

<label class="header">As a team lead, your team gets credit for every success.</label>
<p>You can't take credit for things your team did. You can't even take credit for things you did. You represent the team, and it's your job to make sure the team shares in any success. To do otherwise is to place yourself above the team, and your ability to lead will rapidly decrease if you do that.</p>

<label class="header">Don't give out fake deadlines.</label>
<p>This was a big issue on several projects I was on. We kept receiving deadlines that we were repeatedly told were "critical" to the success of the project. We put in extra effort and care into the project to make the deadline, only to find out it wasn't that important. It decreased our trust towards the leadership, our motivation towards working on the project, and our general feeling of being valued.</p>

<p>Be clear and honest about deadlines and the gravity of them.</p>

<label class="header">Process is important.</label>
<p>On smaller teams with 1-2 developers who know the end state, what needs to be done, and how to do it, it's OK to be loose with processes and "cowboy code". I've been on teams like this and have been incredibly productive.</p>

<p>However, it is ungrowable. Surrounding processes like tracking, monitoring, and automation canâ€™t be done without more solid processes or an established operating doctrine. A project I was on continued the no-process approach even when the team grew. As a result, the team ran around like headless chickens, and quality and output tanked. The business couldn't get information on how the project was proceeding. Managers got nervous (rightfully so!) and start micromanaging by calling meetings and checking in repeatedly. All in all, a bad situation.</p>

As a team grows, codify the knowledge and follow a process to ensure that everyone knows what they should be doing. Apply the proper processes for your team and situation. For most small teams I led, this meant quick (5 minute) daily stand ups, lightweight issue tracking to see project status, and frequent communication, and peer code review during pull requests. That's it.</p>

<label class="header">Maintain a consistent, sustainable tempo.</label>
<p>It's absolutely critical that you keep up a development speed and pattern the team can sustain. If you go too fast, your team burns out, quality and productivity suffer, and development slows to a standstill. If you go too slow, your team gets bored and you waste resources.</p>

<p>When applied in a setting where sprints are used, that means keeping sprints at a consistent duration. If you regularly change the duration of a sprint, it changes the tempo to be unpredictable. Statistics that are tracked become meaningless and workload and release schedules become unpredictable and harder to estimate. It also really drains team motivation - the end of a sprint should seem like a victory where an obstacle was overcome instead of a stream of never-ending issues that must be resolved.</p>


<label class="header">Focus on features that provide value.</label>
<p>I was on a project where, despite my objections, we spent a significant chunk of time on creating full system administration and management features that only 1% of the userbase would use, instead of features that 99% of the users would use. As a result, the quality of the 99%-userbase features suffered, and we weren't able to get some of the things we wanted into those modules.</p>

<p>The sad part is that the 1% of the user base ended up not using the administration/management features, opting instead to have us set it up manually and never touching it again. We could have saved months of development time by opting to write a less user-friendly but effective database script to set it all up.</p>

<label class="header">The only guarantee is change.</label>
<p>I was on a project where I would get these 50-90 page design documents and had to follow the spec to the letter. I would see and point out design flaws, missing edge cases, and requirements issues, but to no avail. I had to follow it. When I did, the spec would change a few days or a week later, forcing me to waste time rewriting significant portions of code to match the spec.</p>

<p>Eventually, I began to NOT follow the spec. I would skim it to get the gist of what the business requirement was, and  develop a solution according to the intent of the requirement. When the spec would change a couple days later, it didn't matter as much because I had done what was needed, not what was asked for. It was significantly faster for me to keep up to date.</p>

<p>Eventually, the spec began to respond to changes in my code instead of the code following the spec, and became more of a documentation of what I did than what the new requirements were. We eventually shifted to a significantly faster and more accurate approach of general requirements instead of detailed step-by-step demands, but that would never have happened by following the design documents.</p>
