---
layout: post
title: HNL.IO - Our Development Processes
blurb: An examination of HNL.IO's development processes.
tags: [Leadership, Software Engineering]
---
<div>
  <p>
    Part of my responsibility as team lead at HNL.IO is to establish our development processes.
    Our company is remote-first, not just remote-friendly. That means that all of our processes support the idea that the people involved won't be in the same room, ever. That doesn't mean our office sits empty - most of the time we come in to the office. It just means that
    our existing development processes could support new additions in a different state or country without skipping a beat.
  </p>
  <p>
    As a startup, a big part of our development process is figuring out what we should build and how we should build it. We've followed the model of releasing lightweight MVPs to validate the usefulness of
    features, and building them further based on user feedback and if they prove to be successful. This process of incrementally and iteratively building on features can happen repeatedly. As a result, we follow
    agile principles in our development process.
  </p>
  <p>
    Agile, at its core, is simply a manifesto that boils down to a set of 12 principles. It's an <a href="http://agilemanifesto.org/">extremely short read</a>, and every software developer should be aware of it.
    People have developed various processes and techniques, "agile methodologies", that attempt to follow these principles. The processes ideally work in conjunction with each other to promote better software development outcomes through iteration, incremental improvement, and stakeholder involvement.
    Some of these methodologies include Scrum, eXtreme Programming, and Kanban, just to name a few.
  </p>
  <p>
    Unfortunately, agile gets a bad rap because many companies simply don't do agile properly. They follow some strange, mutated version of Scrum, and dogmatically hold stand-up meetings, retrospectives, estimation games, etc.
    Ultimately, it doesn't work because they don't follow the spirit of it. As a result, agile is considered a failure or burden. Developers lose motivation, project managers lose control, and the project burns down to the ground.
  </p>
  <p>
    We don't follow one of the traditional processes. Instead, we take parts that make sense, and change or forgo parts that don't.
  </p>

  <h4>Keeping Updated</h4>
  <p>
    <p>
      Team members need to know what's going on and how their work fits in to the rest of the project.
    </p>

    <label>Without A Process</label>
    <p>
      The no-process approach is for the lead to ask the developers for updates. This can work if the team only has two people on it, but if there's more it quickly becomes confusing for everyone but the lead.
      The problem with this approach is that lead effectively hoards all of the knowledge and context of the project, which results in uninformed teams. Teams that don't know what is going on will step on each other's toes
      or waste time spinning their wheels on problems that could have been solved had another person known. It's not just important for the lead to be up-to-date on what's happening on the project - team members need to know, too!
    </p>

    <label>Typical "Agile"</label>
    <p>
      The process used by traditional Scrum and agile teams is the Stand-up meeting. The stand-up is basically a 15-minute meeting where all the participants meet daily at a pre-arranged time and answer the following:
      <ul>
        <li>What did you do the previous day?</li>
        <li>What are you planning on doing that day?</li>
        <li>What is in your way?</li>
      </ul>
    </p>
    <p>
      This can work great, but there's several drawbacks. It's very easy for the stand-up to turn into a long meeting as people ask and questions and things get derailed into a discussion. Typically, these things should be done after
      the stand-up meeting, but often-times they happen during the stand-up or immediately after, which leads everyone into staying for the discussion anyways. Because this is a daily routine, this can easily eat up hours of development
      time, making people think they are being productive when they are really actually wasting time.
    </p>
    <p>
      There's also an insidious psychological effect that occurs if the meeting is early in the day (which is typical of stand-ups). Developers that
      arrive at work before the stand-up often won't actually start working until after the stand-up is over, even if they feel productive. The looming interruption keeps them from making effective use of their time, which can add up to dozens of hours
      per week depending on the team.
    </p>
    <p>
      Stand-ups also don't work as well for a remote environment, setting up various video conferences and other
      things can take up even more time and effort and delay the start of a stand-up.
    </p>
    <p>
      Finally, stand-ups often aren't enough of an update for project managers or those intimiately involved in the development of the product. To remedy this, many take it upon themselves to
      stop by and ask for updates throughout the day, even if an issue tracker is used. This leads to developers feeling like they are being "micro-managed" if the person is a manager and "constantly interrupted" if the person is another developer.
      The interruptions waste a tremendous amount of time as cost of the context-switch required for developers to get back "in the zone" is tremendous, and it builds ill-will on the team.
    </p>
    <label>At HNL.IO</label>

    The approach we have for HNL.IO is a simple variation of the stand-up meeting. We use Slack as our primary communication tool. On Slack, we have a channel called <code>#scrum</code>. Before anyone starts work
    that day, they post the answers to the three questions above...and that's it. Just 3 simple sentences right before they start their work, whenever that time is.

    <p>
      There's no meetings to arrange, and no possibility of random side discussions derailing things.
      Everyone knows what is happening just by reading the channel. If there's any discussion that needs to happen, the individuals involved can have that discussion elsewhere without dragging things into an hour long meeting.
      It's a low-impact, lightweight process that is highly effective in communicating daily updates.
    </p>
    <p>
      To address the issue where the updates aren't frequent enough, we also have a second channel called <code>#whats-up</code>. In this channel, the developers simply put a couple words on what they are working on next.
      Managers wanting more frequent updates and developers who need to know what parts of the project are being worked on can look at this channel and immediately get updated without interrupting the developers. There's no problem
      with the context-switch because developers update it before they start working on something else.
    </p>
  </p>


  <h4>Managing Quality</h4>
  <p>
    <p>
      It's important to create a product that has as few bugs as possible.
    </p>

    <label>Without A Process</label>
    <p>
      The no-process approach is essentially ad-hoc testing, if any, by developers and immediate deployment into a production environment. Obviously, this causes a tremendous amount of bugs and issues.
    </p>

    <label>Typical "Agile"</label>
    <p>
      Most teams that implement Scrum typically doesn't address the prevention of bugs, but rather respond to them. They implement processes to triage bugs and features after they arise, which is too late.
    </p>
    <p>
      Some teams may implement a testing gate prior to deployment, but oftentimes testing itself is not built into the Scrum schedule. These teams often release many bugs and low quality products
      as they are pressed for time and rushed.
    </p>
    <p>
      For the teams that DO consider testing a part of the development process, there's often disagreement on when an issue is considered "done" between developers and project leads.
      "Done" to a developer might mean that the code compiles and is clean, but to a project lead "done" might mean the feature produces correct results regardless of code quality. These lack of consenus in terminology
      is a huge source of issues in effective development and a source of conflict as developers juggle issues that are supposedly "Done" back and forth.
    </p>
    <label>At HNL.IO</label>
    <p>
      The approach we have for HNL.IO is simple. First, we define "done" to mean "tested to produce correct results, meeting a standard of code quality, and ultimately deployable to a production environment."
      It doesn't mean the architecture is the best, or the code will never change again, but rather that any code we accept as "done" should in most situations not come back with bugs or issues, and is easily maintained.
    </p>
    <p>
      To enforce this, we make full use of git's branching and Github's Pull Request feature. When a new feature is started, the developer branches off the <code>dev</code> branch, which contains the latest, stable code
      (<code>master</code> contains the latest deployed code). Once the developer is ready for the code to be reviewed, they make a Pull Request. They add appropriate tags to indicate the size of the feature, any commands that need to be run (such as migrations or bower), and whether
      the Pull Request requires feedback or not. The code is then tested and reviewed by another developer and comments/changes are made as necessary. In rare cases, the original developer can merge in their own Pull Request provided they review a second time
      after some time has passed. It's a 100% remote-compatible process.
    </p>
    <p>
      The result? We have an incredibly low bug rate. The few bugs that did make it into production have been incredibly minor and did not affect usability or functionality. Add on a suite of automated tests and it could reduce that even further.
    </p>
  </p>


  <h4>Planning Ahead</h4>
  <p>
    It's important to know what's coming up and why.
  </p>

  <label>Without A Process</label>
  <p>
    The no-process approach is essentially going back to the lead and asking what to do next. This is ineffective and leads to developers building things that are difficult to expand on, or building the wrong things.
  </p>

  <label>Typical "Agile"</label>
  <p>
    Scrum teams typically use an issue tracker to keep track of their issues, and hold lengthy sprint planning meetings that occur every couple of weeks and take up most of the day.
    In these meetings, they follow the Scrum dogma of playing estimation games, prioritizing and triaging features, and setting the schedule.
  </p>
  <p>
    It should come as no surprise that on most teams, the scope will drastically change halfway through the sprint at the request of the "Scrum Master" or the project manager. New features will be snuck into the sprint backlog, and no extra time will be provided to complete them.
    Most teams, endeavoring to look good in front of their superiors, will severely underestimate the amount of time issues will take to complete, or when pressed to reduce the estimate, will comply despite the fact the initial estimate was already too low.
    When the sprint comes to a close, there will either be a plethora of issues that are not completed, leading to punishment of the team for not being productive, or the issues will be completed with incredibly low quality, leading to the punishment
    of the team for not producing quality results. Then, the cycle repeats until the project is cancelled or fails.
  </p>
  <label>At HNL.IO</label>
  <p>
    At HNL.IO, we avoid these heavy-handed processes. Instead, we follow a release schedule - we deploy the product every week on Tuesday with whatever features were completed.
    We use lightweight, broad estimates, knowing that estimates run over frequently, to gauge what the product will look like in several weeks, but not to plan the next set of features.
  </p>
  <p>
    Because we don't plan the scope of the sprint, we can adapt to changing priorities and requirements quickly. If something doesn't make it into a deploy - no problem, it'll go into the next deploy.
    We also do the occasional out-of-band deployment if a valuable feature was finished shortly after the scheduled deploy. The deployment process is very simple - run a command and let the automated systems do the work!
  </p>
  <p>
    We use an issue tracker to provide a backlog of work to draw from. We keep track of all of our issues, features, bugs, ideas, etc., on <a href="https://kanbanflow.com">KanbanFlow</a>. The board is accessible to the entire team.
    Issues are color-coded based on type (task, bug, feature, improvement, etc.) and initially go in one of three columns ("On Hold", "Backlog", and "Priority"). Developers choose what they want to work on from the Priority and Backlog
    and move the issues through the columns "In Progress", "Needs Review", and "Done". It's simple, lightweight remote-friendly, and gives a good idea of what needs to be done next and where the product is going. We triage issues as
    needed.
  </p>
  <p>
    We've developed a short-term feature roadmap so that the team knows the value of each feature they are working on and can contribute to the discussion as necessary. It also helps mold the development
    of connected features - if we know that another feature is going to be built on top of the current feature, we can plan ahead and design it in an expandable way so that the next feature is easier to add. We don't add things we don't need - we just
    plan for it. We effectively "grow" our software instead of having an unchangeable master plan or sprawling spaghetti mess.
  </p>
  <p>
    The end result - planning is a breeze and truly adaptable to rapidly changing constraints in the environment.
  </p>

  <p>
    That's a glimpse into our development process. It's always improving as we discover things that work better and things that don't work as well as they should.
  </p>
</div>
