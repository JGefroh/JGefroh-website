---
layout: post
title: Lessons Learned, Part 2
blurb: An examination of various decisions and mistakes I've made in the past.
tags: [Software Engineering, Leadership]
---
<p>
  A developer makes thousands of decisions a day that can affect the outcome of a project.
  Name a variable <code>x</code> instead of <code>elapsedTimeInMilliseconds</code>?
  Ding! It just got that much harder for the next programmer to understand your code.
  Decide to create a proper join table instead of storing everything as a comma-separated string? Congratulations, you just saved two weeks of development time 3 months from now.
</p>
<p>
  The effects of the decisions developers make accumulate and are compounded as time goes on. If the decisions are good, then you're on your way to a succesful project. If not, you may face a maintenance nighmare 10 years from now (if you even manage to launch)!
</p>
<p>
  Scarily, most of these decisions are made subconsciously without thought or reasoning.
  Projects succeed or fail based entirely on luck. That's not good.
</p>
<p>
  As a lead on multiple projects, it's been my job to ensure I've thought about these decisions consciously and weighed the tradeoffs.
  I've had to make many large-scale decisions that have had both positive and negative affects on the project both in the long-term and short-term.
</p>
<p>
  Here's some of the decisions I've made, with the magic of 20/20 hindsight.
</p>

<label class="header">Mo' columns, mo' problems.</label>
<p>
  A project I was working needed a way to mark individual fields of a record invalid as part of its record approval workflow.
   At the time, I decided that it'd be easier to store the booleans in individual columns in the same table.
   As a result, the table structure looked like this:
   <pre>col1, col1_is_marked, col2, col2_is_marked, col3, col3_is_marked</pre>
   ....and so on. The reasoning was that checking and modifying a boolean was simple,
   mapped easily to the frontend, and only required a few extra changes in the mappers, allowing us to not change the surrounding business logic.
</p>
<p>
  Big mistake.
</p>

<p>
  There's really no defending that decision. Sure, checking a boolean is easier in the short term, but there's a lot that can go wrong with it.
  <ul>
    <li>if columns are added, the table and all associated code will have to be changed again.</li>
    <li>queries to return if a specific field is marked get MUCH more complicated to write - you have to include every single is_marked field.</li>
  </ul>
  <p>By sheer luck, we didn't have to query off of those fields. But, predictably, the requirements changed and the table had many
     extra additions and removals of various fields. As a result, every time the table structure changed, we had to change the mappers. This happened quite a bit.</p>
</p>
<p>
  The alternative (which we eventually switched to long after), is to create a separate table representing marked fields. The table would look like the following:
  <pre>record_id, col_name, is_marked</pre>
  A structure like that would allow us to simply add and remove from the list to indicate if a field of a record was marked or not. If new fields were added,
  no code would have to be changed. It would automatically work because all you would have to do is insert a new record with the new field name. It was a bit more work upfront,
  but from a maintenance perspective it was incredibly lightweight.
</p>


<label class="header">Never = Later</label>
<p>
  The requirements came in from our business analyst - there's going to be a single appropriation account associated with
  a record. Will a record ever have more than one account? No! Never! Preposterous! The client's processes would never allow for it!
</p>
<p>
  It's tempting: a 1-1 relationship mapping is easy to do and requires little effort, whereas a many-to-many is somewhat more complicated.
  If it'll never change, might as well do the simpler thing, right? Preventing over-engineering is a good goal, isn't it?
</p>
<p>
  I wish I could say the first time this happened, I was smart enough to realize that in the world of software development, never = later. Unfortunately,
  I fell into this trap and designed the module with a 1-1 mapping. Later on, when the requirements inevitably changed, it required a significant rewrite across the entire stack to support the multiple account association.
</p>
<p>
    I've encountered this situation again and again on different projects. Luckily, I learned my lesson early on and now
    look ahead when I encounter a potential 1-1 relationship, even if the current requirements would never change.
    If there's any remote chance there will ever be multiple of an association, I design it as a many-to-one from the beginning.
    It has saved me from many a module rewrite for very little upfront cost.
</p>


<label class="header">Later = Never</label>
<p>
  "Put a TODO comment there and we'll fix it later."
</p>
<p>
  Turns out later never came. I stumbled on the comment months later - it was never fixed. Whether it's a bug or some unclear code you were too lazy to remove, chances are
  it's still there, waiting for you to come back...but you never will.
</p>
<p>
  If you feel like something can be put off until later - stop and re-evaluate. Understand that priorities change and things get forgotten. People rarely search through their code
  for their "TODO" comments. Take the extra time to do it right - who knows what'll happen tomorrow. In the rare cases where I do put things off until later, I always make it a point to
  create an issue to get back to it, and make it a point to make time to make the change, even if it means putting off other things. It's the least I can do to help ensure that it won't be forgotten or buried.
</p>


<label class="header">Validate your assumptions and don't over-engineer.</label>
<p>
  One of the assumptions made on HNL.IO early on was that people would be sending many emails using our system. It made sense on the surface - we were an event platform, and people
  would need to send mass invites to mailing lists, friends, contacts, etc.
</p>
<p>
  The mistake I made was thinking that we had to provide a comprehensive emailing system to allow our users to create and send high-quality emails easily.
  I spent several weeks building up an email template system, complete with real-time email preview, pre-made and customizable templates, and a contact list management system. It
  allowed users full control over the appearance of the email and made it easy to send high-quality event invitations with a single click.
</p>
<p>
  During the six months the feature was in production, it was used by a total of 0 people. That's right - zip, nada. The reason? People already had their email services, contact list management, and communication channels
  - whether it be MadMimi, MailChimp, or Facebook. They didn't need or want another internal event invite email creator. We could have saved several weeks of development effort had I just added a basic emailer and monitored
  usage statistics, or done some low-cost research with our users. The feature was eventually removed entirely, and a lesson was learned the hard way.
</p>


<label class="header">Automate early, automate often.</label>
<p>
  Early on in a project, my teammate requested multiple times if we could automate the build. At that time, the build wasn't difficult - it took maybe 3- 10 minutes
  to complete, and it was done once or twice a month. We had a lot of features to work on, so I told her "no, we don't need it."
</p>
<p>
  As time went by, the build got more and more complicated and so did the frequency of deploys.
  Towards the end of the project, it was over a dozen steps long, took about 30-50 minutes to complete,
  and we were deploying multiple times a week to multiple environments. </p>
<p>
  By then it was too late - the project has become incredibly complex,
  and some modules just weren't engineered to support automated builds - it would have taken a significant amount of time to make it compatible.
  Had I listened to my teammate when she first asked to automate the build, we could have built in support for deployment automation
  early on and saved a lot of time and effort. Instead, I had decided against it. As a result, the entire team struggled with deploys
  - several deploys even had mistakes and failed, wasting more time and effort.
</p>
<p>
  I don't make that mistake anymore. From the very beginning of projects, I'm now very cognizant of how the application will eventually be deployed,
  and what we can do early on to support automated deployments, even if it will take a bit of upfront effort. I've seen the damage of unautomated,
  complex deployments, and I've learned from it.
</p>
